<h1> Software Engineering at Google, Oreilly. </h1>

<h2> Primeiro Trecho: </h2>
Discute a diferença entre programação, ciência da computação e engenharia de software. Ele destaca que, embora muitas vezes sejam tratados como sinônimos, cada termo tem um foco diferente. A ciência da computação é mais teórica; programação é o ato de escrever código; já a engenharia de software envolve aplicar conhecimento técnico de forma sistemática para construir sistemas reais e confiáveis. Também compara a engenharia de software com outras engenharias tradicionais (como a civil ou a aeronáutica), que têm processos rigorosos e consequências diretas no mundo físico. A engenharia de software ainda não tem esse mesmo nível de rigor, mas deveria caminhar nessa direção — principalmente porque hoje os softwares impactam cada vez mais o nosso cotidiano. O objetivo é que os desenvolvedores adotem práticas mais sérias e sustentáveis, assim como em outras engenharias.

<h2> Segundo Trecho: </h2>
Amplia a definição de engenharia de software, explicando que ela vai muito além de apenas programar. Envolve tudo o que é necessário para manter um software útil e saudável com o passar do tempo: ferramentas, processos, manutenção, escalabilidade, e decisões estratégicas. Um conceito central do trecho é o de “programação integrada ao longo do tempo”. Isso quer dizer que não basta escrever um código que funcione hoje — ele precisa continuar funcionando bem no futuro, se adaptar a mudanças, e ser compreensível para outras pessoas ao longo do tempo.

<h2> 3 Exemplos de Trade-Offs: </h2>

1. Velocidade de desenvolvimento vs. qualidade do código

Trade-off: Escrever código rapidamente pode ser necessário em fases iniciais de um projeto ou quando há pressão por entrega, mas isso geralmente compromete a qualidade do código.

Impacto: Código mal projetado tende a gerar problemas futuros, como bugs difíceis de resolver ou dificuldade de manutenção.


2. Reutilização de código vs. complexidade

Trade-off: Criar código altamente reutilizável (por exemplo, bibliotecas genéricas) pode tornar o sistema mais modular, mas também pode introduzir mais abstrações e complexidade desnecessária.

Impacto: Em projetos menores, isso pode dificultar a compreensão do código; em projetos maiores, pode ser essencial para manter consistência e escalabilidade.

3. Otimização de desempenho vs. legibilidade

Trade-off: Melhorar a performance de um sistema às vezes exige técnicas mais complexas ou menos intuitivas (como manipulação de baixo nível, caching, paralelismo).

Impacto: Isso pode tornar o código mais difícil de entender e manter, mesmo que ele seja mais rápido na execução.


